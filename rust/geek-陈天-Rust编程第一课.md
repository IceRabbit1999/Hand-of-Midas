# 前置篇

## 内存：堆和栈

1. 对于存入栈上的值，它的大小在编译期就需要确定。栈上存储的变量生命周期在当前调用栈的作用域内，无法跨调用栈引用。
2. 堆可以存入大小未知或者动态伸缩的数据类型。堆上存储的变量，其生命周期从分配后开始，一直到释放时才结束，因此堆上的变量允许在多个调用栈之间引用
   1. 但也导致堆变量的管理非常复杂，手工管理会引发很多内存安全性问题，而自动管理，无论是 GC 还是 ARC，都有性能损耗和其它问题。
3. 栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期。

## 一些基本概念

### 指针和引用

1. 引用的解引用访问是受限的，它只能解引用到它引用数据的类型，不能用作它用
2. 指针和引用是原生类型，它们可以分配在栈上。

### 接口和虚表

1. 在运行时，一旦使用了关于接口的引用，变量原本的类型被抹去，我们无法单纯从一个指针分析出这个引用具备什么样的能力
2. 因此，在生成这个引用的时候，我们需要构建胖指针，除了指向数据本身外，还需要指向一张涵盖了这个接口所支持方法的列表
3. 虚表记录了数据能够执行的接口，所以在运行期，我们想对一个接口有不同实现，可以根据上下文动态分派



# 基础篇

## 所有权：值的生杀大权

所有权：一个值只能被一个变量所拥有，且同一时刻只能有一个所有者，当所有者离开作用域，其拥有的值被丢弃，内存得到释放



所有权规则，解决了谁真正拥有数据的生杀大权问题，让堆上数据的多重引用不复存在，这是它最大的优势



如果你不希望值的所有权被转移:

1. 如果一个数据结构实现了 Copy trait，那么它就会使用 Copy 语义。这样，在你赋值或者传参时，值会自动按位拷贝（浅拷贝）
2. 你可以 “借用” 数据

+ 原生类型，包括函数、不可变引用和裸指针实现了 Copy；
+ 数组和元组，如果其内部的数据结构实现了 Copy，那么它们也实现了 Copy；
+ 可变引用没有实现 Copy；
+ 非固定大小的数据结构，没有实现 Copy

## 所有权：值的借用

1. Borrow 语义通过引用语法（& 或者 &mut）来实现
2. 在Rust中，“借用” 和 “引用” 是一个概念，所有的引用都只是借用了 “临时使用权”，它并不破坏值的单一所有权约束
3. 默认情况下，Rust的借用都是只读的
4. Rust 没有传引用的概念，Rust 所有的参数传递都是传值
5. 只读引用实现了 Copy trait，也就意味着引用的赋值、传参都会产生新的浅拷贝
6. 借用不能超过（outlive）值的生存期
7. 一个值可以有多个只读引用。
8. if you have a mutable reference to a value, you can have no other references to that value， 一个值可以有唯一一个活跃的可变引用。可变引用（写）和只读引用（读）是互斥的关系

## 所有权：多个所有者

1. Box::leak ()，顾名思义，它创建的对象，从堆内存上泄漏出去，不受栈内存控制，是一个自由的、生命周期可以大到和整个进程的生命周期一致的对象。有了 Box::leak ()，我们就可以跳出 Rust 编译器的静态检查，保证 Rc 指向的堆内存，有最大的生命周期

## 生命周期

1. 在任何语言里，栈上的值都有自己的生命周期，它和帧的生命周期一致
2. 在 Rust 中，除非显式地做 Box::leak () / Box::into_raw () / ManualDrop 等动作，一般来说，堆内存的生命周期，会默认和其栈内存的生命周期绑定在一起。
3. 生命周期参数，描述的是参数和参数之间、参数和返回值之间的关系，并不改变原有的生命周期
4. 编译器自动添加标注
   1. 所有引用类型的参数都有独立的生命周期 'a 、'b 等。
   2. 如果只有一个引用型输入，它的生命周期会赋给所有输出。
   3. 如果有多个引用类型的参数，其中一个是 self，那么它的生命周期会赋给所有输出。
5. 生命周期标注的目的是，在参数和返回值之间建立联系或者约束
6. 使用数据结构时，数据结构自身的生命周期，需要小于等于其内部字段的所有引用的生命周期

## 内存管理

1. Rust 在内存中排布数据时，会根据每个域的对齐（aligment）对数据进行重排，使其内存大小和访问效率最好。比如，一个包含 A、B、C 三个域的 struct，它在内存中的布局可能是 A、C、B

## 类型系统

1. 类型，是对值的区分，它包含了值在内存中的长度、对齐以及值可以进行的操作等信息。类型系统其实就是，对类型进行定义、检查和处理的系统
2. 从内存的角度看，类型安全是指代码，只能按照被允许的方法，访问它被授权访问的内存。
3. 按类型定义、检查以及检查时能否被推导出来，Rust 是强类型 + 静态类型 + 显式类型。

## 类型系统：trait

+ Self 代表当前的类型，比如 File 类型实现了 Write，那么实现过程中使用到的 Self 就指代 File。
+ self 在用作方法的第一个参数时，实际上是 self: Self 的简写，所以 &self 是 self: &Self, 而 &mut self 是 self: &mut Self。

1. 如果 trait 所有的方法，返回值是 Self 或者携带泛型参数，那么这个 trait 就不能产生 trait object
   1. 不允许返回 Self，是因为 trait object 在产生时，原来的类型会被抹去，所以 Self 究竟是谁不知道。
   2. 不允许携带泛型参数，是因为 Rust 里带泛型的类型在编译时会做单态化，而 trait object 是运行时的产物，两者不能兼容。

## 类型系统：常用trait

1. 内存相关：Clone / Copy / Drop
   1. Copy trait 和 Drop trait 是互斥的，两者不能共存。Copy 是按位做浅拷贝，那么它会默认拷贝的数据没有需要释放的资源；而 Drop 恰恰是为了释放额外的资源而生的。
2. 标记 trait：Sized / Send / Sync / Unpin
   1. 如果一个类型 T 实现了 Send trait，意味着 T 可以安全地从一个线程移动到另一个线程，也就是说所有权可以在线程间移动。
   2. 如果一个类型 T 实现了 Sync trait，则意味着 &T 可以安全地在多个线程中共享。一个类型 T 满足 Sync trait，当且仅当 &T 满足 Send trait。
   3. 如果一个类型 T: Send，那么 T 在某个线程中的独占访问是线程安全的；如果一个类型 T: Sync，那么 T 在线程间的只读共享是安全的。
3. 类型转换相关：From / Into/AsRef / AsMut
   1. 值类型到值类型的转换：From / Into / TryFrom / TryInto
   2. 引用类型到引用类型的转换：AsRef / AsMut
4. 操作符相关：Deref / DerefMut
5. 其它：Debug / Display / Default

## 数据结构：智能指针

1. 智能指针 String 和胖指针 &str 的区别
   1. String 对堆上的值有所有权，而 &str 是没有所有权的，这是 Rust 中智能指针和普通胖指针的区别。
2. 在 Rust 中，凡是需要做资源回收的数据结构，且实现了 Deref/DerefMut/Drop，都是智能指针