[Rust 语言圣经 - Rust 语言圣经 (Rust Course)](https://course.rs/about-book.html)

[toc]

# 1. 快速开始

1. 什么情况下该把 `Cargo.lock` 上传到 git 仓库里？很简单，当你的项目是一个可运行的程序时，就上传 `Cargo.lock`，如果是一个依赖库项目，那么请把它添加到 `.gitignore` 中

# 2. Rust基础入门

## 2.1 变量绑定与解构

### 使用下划线开头忽略未使用的变量 

`let _unused = 5;`

### 变量解构

从一个相对复杂的变量中，匹配出该变量的一部分内容

应该是对应destructing

## 2.2 基本类型

### 2.2.1 数值类型

#### 整形溢出

当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时*panic*

在当使用 `--release` 参数进行 release 模式构建时，Rust**不**检测溢出 （当检测到整型溢出时，Rust 会按照补码循环溢出（*two’s complement wrapping*）的规则处理）

#### 浮点数陷阱

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

```rust
fn main() {
  // 断言0.1 + 0.2与0.3相等，会 panic
  assert!(0.1 + 0.2 == 0.3);
}
```

`f32` 下的 `0.1 + 0.2 == 0.3` 通过测试，但是到了 `f64` 类型时，结果就不一样了，因为 `f64` 精度高很多，因此在小数点非常后面发生了一点微小的变化

#### NAN

所有跟 `NaN` 交互的操作，都会返回一个 `NaN`，而且 `NaN` 不能用来比较

`is_nan()`可以用来判断一个数值是否是 `NaN`

#### 数字运算

只有同样类型，才能运算

#### 序列

`1..5`: 1,2,3,4,

`1..=5`: 1,2,3,4,5

序列只允许用于数字或字符类型, 字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型

#### 差异

- 类型转换必须是显式的. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数
- Rust 的数值上可以使用方法. 例如你可以用以下方法来将 `13.14` 取整：`13.14_f32.round()`

### 2.2.2 字符、布尔、单元类型

