[Rust 语言圣经 - Rust 语言圣经 (Rust Course)](https://course.rs/about-book.html)

[toc]

# 1. 快速开始

1. 什么情况下该把 `Cargo.lock` 上传到 git 仓库里？很简单，当你的项目是一个可运行的程序时，就上传 `Cargo.lock`，如果是一个依赖库项目，那么请把它添加到 `.gitignore` 中

# 2. Rust基础入门

## 2.1 变量绑定与解构

### 使用下划线开头忽略未使用的变量 

`let _unused = 5;`

### 变量解构

从一个相对复杂的变量中，匹配出该变量的一部分内容

应该是对应destructing

## 2.2 基本类型

### 2.2.1 数值类型

#### 整形溢出

当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时*panic*

在当使用 `--release` 参数进行 release 模式构建时，Rust**不**检测溢出 （当检测到整型溢出时，Rust 会按照补码循环溢出（*two’s complement wrapping*）的规则处理）

#### 浮点数陷阱

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

```rust
fn main() {
  // 断言0.1 + 0.2与0.3相等，会 panic
  assert!(0.1 + 0.2 == 0.3);
}
```

`f32` 下的 `0.1 + 0.2 == 0.3` 通过测试，但是到了 `f64` 类型时，结果就不一样了，因为 `f64` 精度高很多，因此在小数点非常后面发生了一点微小的变化

#### NAN

所有跟 `NaN` 交互的操作，都会返回一个 `NaN`，而且 `NaN` 不能用来比较

`is_nan()`可以用来判断一个数值是否是 `NaN`

#### 数字运算

只有同样类型，才能运算

#### 序列

`1..5`: 1,2,3,4,

`1..=5`: 1,2,3,4,5

序列只允许用于数字或字符类型, 字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型

#### 差异

- 类型转换必须是显式的. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数
- Rust 的数值上可以使用方法. 例如你可以用以下方法来将 `13.14` 取整：`13.14_f32.round()`

### 2.2.3 语句和表达式

能返回值，它就是表达式:

**表达式不能包含分号**

表达式如果不返回任何值，会隐式地返回一个 `()`

### 2.2.4 函数

- 函数没有返回值，那么返回一个 `()`
- 通过 `;` 结尾的表达式返回一个 `()`
- 当用 `!` 作函数返回类型的时候，表示该函数永不返回 (diverge function)，特别的，这种语法往往用做会导致程序崩溃的函数

## 2.3 所有权和借用

### 2.3.1 所有权

#### 栈和堆

1. 栈中的所有数据都必须占用已知且固定大小的内存空间

2. 对于大小未知或者可能变化的数据，我们需要将它存储在堆上，堆是一种缺乏组织的数据结构
3. 入栈比在堆上分配内存要快，访问堆上的数据比访问栈上的数据慢
4. 当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除

#### 所有权原则

1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3. 当所有者 (变量) 离开作用域范围时，这个值将被丢弃 (drop)



1. **Rust 永远也不会自动创建数据的 “深拷贝”**。因此，任何**自动**的复制都不是深拷贝

2. **任何基本类型的组合可以 `Copy` ，不需要分配内存或某种形式资源的类型是可以 `Copy` 的**（copy: 一个旧的变量在被赋值给其他变量后仍然可用）

3. `move`: 浅拷贝 + drop原始变量
4. 将值传递给函数，一样会发生 `move` 或者 `copy`

### 2.3.2 引用与借用

**获取变量的引用，称之为借用 (borrowing)**

1. 正如变量默认不可变一样，引用指向的值默认也是不可变的
2. **同一作用域，特定数据只能有一个可变引用**
3. 可变引用与不可变引用不能同时存在

- 同一时刻，你只能拥有要么一个可变引用，要么任意多个不可变引用
- 引用必须总是有效的

## 2.4 复合类型

### 2.4.1 字符串与切片

#### 切片

1. 切片允许你引用集合中部分连续的元素序列，而不是引用整个集合。

2. 在对字符串使用切片语法时需要格外小心，切片的索引必须落在字符之间的边界位置，也就是 UTF-8 字符的边界，例如中文在 UTF-8 中占用三个字节

#### 字符串

1. **Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的 (1 - 4)**

### 2.4.2 元组

元组的长度是固定的，元组中元素的顺序也是固定的，可以使用模式匹配或者 `.` 操作符来获取元组中的值

### 2.4.3 结构体

1. 当函数参数和结构体字段同名时，可以直接使用缩略的方式进行初始化

2. 元组结构体在你希望有一个整体名称，但是又不关心里面字段的名称时将非常有用 `struct Color(i32, i32, i32); `

3. 如果你定义一个类型，但是不关心该类型的内容，只关心它的行为时，就可以使用

```rust
struct AlwaysEqual;

let subject = AlwaysEqual;

// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征
impl SomeTrait for AlwaysEqual {

}
```

抽象类actually